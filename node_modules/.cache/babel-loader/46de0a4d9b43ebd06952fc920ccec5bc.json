{"remainingRequest":"/Users/crocslut/Desktop/Git/main-cleanaway-pwa/node_modules/babel-loader/lib/index.js!/Users/crocslut/Desktop/Git/main-cleanaway-pwa/node_modules/cache-loader/dist/cjs.js??ref--0-0!/Users/crocslut/Desktop/Git/main-cleanaway-pwa/node_modules/vue-loader-v16/dist/index.js??ref--0-1!/Users/crocslut/Desktop/Git/main-cleanaway-pwa/src/views/treetable/TreeTableLazyDemo.vue?vue&type=script&lang=js","dependencies":[{"path":"/Users/crocslut/Desktop/Git/main-cleanaway-pwa/src/views/treetable/TreeTableLazyDemo.vue","mtime":1634589566292},{"path":"/Users/crocslut/Desktop/Git/main-cleanaway-pwa/node_modules/cache-loader/dist/cjs.js","mtime":1634585934434},{"path":"/Users/crocslut/Desktop/Git/main-cleanaway-pwa/node_modules/babel-loader/lib/index.js","mtime":1634585934594},{"path":"/Users/crocslut/Desktop/Git/main-cleanaway-pwa/node_modules/cache-loader/dist/cjs.js","mtime":1634585934434},{"path":"/Users/crocslut/Desktop/Git/main-cleanaway-pwa/node_modules/vue-loader-v16/dist/index.js","mtime":1634585949898}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:aW1wb3J0IF9vYmplY3RTcHJlYWQgZnJvbSAiL1VzZXJzL2Nyb2NzbHV0L0Rlc2t0b3AvR2l0L21haW4tY2xlYW5hd2F5LXB3YS9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vb2JqZWN0U3ByZWFkMiI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLmZ1bmN0aW9uLm5hbWUuanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5tYXAuanMiOwpleHBvcnQgZGVmYXVsdCB7CiAgZGF0YTogZnVuY3Rpb24gZGF0YSgpIHsKICAgIHJldHVybiB7CiAgICAgIG5vZGVzOiBudWxsLAogICAgICByb3dzOiAxMCwKICAgICAgbG9hZGluZzogZmFsc2UsCiAgICAgIHRvdGFsUmVjb3JkczogMCwKICAgICAgc291cmNlczogewogICAgICAgICdvcHRpb25zLWFwaSc6IHsKICAgICAgICAgIHRhYk5hbWU6ICdPcHRpb25zIEFQSSBTb3VyY2UnLAogICAgICAgICAgY29udGVudDogIlxuPHRlbXBsYXRlPlxuICAgIDxkaXY+XG4gICAgICAgIDxUcmVlVGFibGUgOnZhbHVlPVwibm9kZXNcIiA6bGF6eT1cInRydWVcIiA6cGFnaW5hdG9yPVwidHJ1ZVwiIDpyb3dzPVwicm93c1wiIDpsb2FkaW5nPVwibG9hZGluZ1wiXG4gICAgICAgICAgICBAbm9kZUV4cGFuZD1cIm9uRXhwYW5kXCIgQHBhZ2U9XCJvblBhZ2VcIiA6dG90YWxSZWNvcmRzPVwidG90YWxSZWNvcmRzXCI+XG4gICAgICAgICAgICA8Q29sdW1uIGZpZWxkPVwibmFtZVwiIGhlYWRlcj1cIk5hbWVcIiA6ZXhwYW5kZXI9XCJ0cnVlXCI+PC9Db2x1bW4+XG4gICAgICAgICAgICA8Q29sdW1uIGZpZWxkPVwic2l6ZVwiIGhlYWRlcj1cIlNpemVcIj48L0NvbHVtbj5cbiAgICAgICAgICAgIDxDb2x1bW4gZmllbGQ9XCJ0eXBlXCIgaGVhZGVyPVwiVHlwZVwiPjwvQ29sdW1uPlxuICAgICAgICA8L1RyZWVUYWJsZT5cbiAgICA8L2Rpdj4gICAgICAgICAgICAgICAgICAgXG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuZXhwb3J0IGRlZmF1bHQge1xuICAgIGRhdGEoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBub2RlczogbnVsbCxcbiAgICAgICAgICAgIHJvd3M6IDEwLFxuICAgICAgICAgICAgbG9hZGluZzogZmFsc2UsXG4gICAgICAgICAgICB0b3RhbFJlY29yZHM6IDBcbiAgICAgICAgfVxuICAgIH0sXG4gICAgbW91bnRlZCgpIHtcbiAgICAgICAgdGhpcy5sb2FkaW5nID0gdHJ1ZTtcblxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMubG9hZGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5ub2RlcyA9IHRoaXMubG9hZE5vZGVzKDAsIHRoaXMucm93cyk7XG4gICAgICAgICAgICB0aGlzLnRvdGFsUmVjb3JkcyA9IDEwMDA7XG4gICAgICAgIH0sIDEwMDApO1xuICAgIH0sXG4gICAgbWV0aG9kczoge1xuICAgICAgICBvbkV4cGFuZChub2RlKSB7XG4gICAgICAgICAgICBpZiAoIW5vZGUuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvYWRpbmcgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBsYXp5Tm9kZSA9IHsuLi5ub2RlfTtcblxuICAgICAgICAgICAgICAgICAgICBsYXp5Tm9kZS5jaGlsZHJlbiA9IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IGxhenlOb2RlLmRhdGEubmFtZSArICcgLSAwJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZTogTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTAwMCkgKyAxICsgJ2tiJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ0ZpbGUnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBsYXp5Tm9kZS5kYXRhLm5hbWUgKyAnIC0gMScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpemU6IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDEwMDApICsgMSArICdrYicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdGaWxlJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgXTtcblxuICAgICAgICAgICAgICAgICAgICBsZXQgbm9kZXMgPSB0aGlzLm5vZGVzLm1hcChuID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuLmtleSA9PT0gbm9kZS5rZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuID0gbGF6eU5vZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuO1xuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICB0aGlzLmxvYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ub2RlcyA9IG5vZGVzO1xuICAgICAgICAgICAgICAgIH0sIDI1MCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG9uUGFnZShldmVudCkge1xuICAgICAgICAgICAgdGhpcy5sb2FkaW5nID0gdHJ1ZTtcblxuICAgICAgICAgICAgLy9pbWl0YXRlIGRlbGF5IG9mIGEgYmFja2VuZCBjYWxsXG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLm5vZGVzID0gdGhpcy5sb2FkTm9kZXMoZXZlbnQuZmlyc3QsIHRoaXMucm93cyk7XG4gICAgICAgICAgICB9LCAxMDAwKTtcbiAgICAgICAgfSxcbiAgICAgICAgbG9hZE5vZGVzKGZpcnN0LCByb3dzKSB7XG4gICAgICAgICAgICBsZXQgbm9kZXMgPSBbXTtcblxuICAgICAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IHJvd3M7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBub2RlID0ge1xuICAgICAgICAgICAgICAgICAgICBrZXk6IChmaXJzdCArIGkpLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnSXRlbSAnICsgKGZpcnN0ICsgaSksXG4gICAgICAgICAgICAgICAgICAgICAgICBzaXplOiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxMDAwKSArIDEgKyAna2InLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ1R5cGUgJyArIChmaXJzdCArIGkpXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGxlYWY6IGZhbHNlXG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIG5vZGVzLnB1c2gobm9kZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBub2RlcztcbiAgICAgICAgfVxuICAgIH1cbn1cbjxcXC9zY3JpcHQ+XG4iCiAgICAgICAgfSwKICAgICAgICAnY29tcG9zaXRpb24tYXBpJzogewogICAgICAgICAgdGFiTmFtZTogJ0NvbXBvc2l0aW9uIEFQSSBTb3VyY2UnLAogICAgICAgICAgY29udGVudDogIlxuPHRlbXBsYXRlPlxuICAgIDxkaXY+XG4gICAgICAgIDxUcmVlVGFibGUgOnZhbHVlPVwibm9kZXNcIiA6bGF6eT1cInRydWVcIiA6cGFnaW5hdG9yPVwidHJ1ZVwiIDpyb3dzPVwicm93c1wiIDpsb2FkaW5nPVwibG9hZGluZ1wiXG4gICAgICAgICAgICBAbm9kZUV4cGFuZD1cIm9uRXhwYW5kXCIgQHBhZ2U9XCJvblBhZ2VcIiA6dG90YWxSZWNvcmRzPVwidG90YWxSZWNvcmRzXCI+XG4gICAgICAgICAgICA8Q29sdW1uIGZpZWxkPVwibmFtZVwiIGhlYWRlcj1cIk5hbWVcIiA6ZXhwYW5kZXI9XCJ0cnVlXCI+PC9Db2x1bW4+XG4gICAgICAgICAgICA8Q29sdW1uIGZpZWxkPVwic2l6ZVwiIGhlYWRlcj1cIlNpemVcIj48L0NvbHVtbj5cbiAgICAgICAgICAgIDxDb2x1bW4gZmllbGQ9XCJ0eXBlXCIgaGVhZGVyPVwiVHlwZVwiPjwvQ29sdW1uPlxuICAgICAgICA8L1RyZWVUYWJsZT5cbiAgICA8L2Rpdj4gICAgICAgICAgICAgICAgICAgXG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuaW1wb3J0IHsgcmVmLCBvbk1vdW50ZWQgfSBmcm9tICd2dWUnO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gICAgc2V0dXAoKSB7XG4gICAgICAgIG9uTW91bnRlZCgoKSA9PiB7XG4gICAgICAgICAgICBsb2FkaW5nLnZhbHVlID0gdHJ1ZTtcblxuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgbG9hZGluZy52YWx1ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIG5vZGVzLnZhbHVlID0gbG9hZE5vZGVzKDAsIHJvd3MudmFsdWUpO1xuICAgICAgICAgICAgICAgIHRvdGFsUmVjb3Jkcy52YWx1ZSA9IDEwMDA7XG4gICAgICAgICAgICB9LCAxMDAwKTtcbiAgICAgICAgfSlcbiAgICAgICAgY29uc3Qgbm9kZXMgPSByZWYoKTtcbiAgICAgICAgY29uc3Qgcm93cyA9IHJlZigxMCk7XG4gICAgICAgIGNvbnN0IGxvYWRpbmcgPSByZWYoZmFsc2UpO1xuICAgICAgICBjb25zdCB0b3RhbFJlY29yZHMgPSByZWYoMCk7XG4gICAgICAgIGNvbnN0IG9uRXhwYW5kID0gKG5vZGUpID0+IHtcbiAgICAgICAgICAgIGlmICghbm9kZS5jaGlsZHJlbikge1xuICAgICAgICAgICAgICAgIGxvYWRpbmcudmFsdWUgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBsYXp5Tm9kZSA9IHsuLi5ub2RlfTtcblxuICAgICAgICAgICAgICAgICAgICBsYXp5Tm9kZS5jaGlsZHJlbiA9IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IGxhenlOb2RlLmRhdGEubmFtZSArICcgLSAwJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZTogTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTAwMCkgKyAxICsgJ2tiJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ0ZpbGUnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBsYXp5Tm9kZS5kYXRhLm5hbWUgKyAnIC0gMScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpemU6IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDEwMDApICsgMSArICdrYicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdGaWxlJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgXTtcblxuICAgICAgICAgICAgICAgICAgICBsZXQgbmV3Tm9kZXMgPSBub2Rlcy52YWx1ZS5tYXAobiA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobi5rZXkgPT09IG5vZGUua2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbiA9IGxhenlOb2RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbjtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgbG9hZGluZy52YWx1ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBub2Rlcy52YWx1ZSA9IG5ld05vZGVzO1xuICAgICAgICAgICAgICAgIH0sIDI1MCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IG9uUGFnZSA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgbG9hZGluZy52YWx1ZSA9IHRydWU7XG5cbiAgICAgICAgICAgIC8vaW1pdGF0ZSBkZWxheSBvZiBhIGJhY2tlbmQgY2FsbFxuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgbG9hZGluZy52YWx1ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIG5vZGVzLnZhbHVlID0gbG9hZE5vZGVzKGV2ZW50LmZpcnN0LCByb3dzLnZhbHVlKTtcbiAgICAgICAgICAgIH0sIDEwMDApO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBsb2FkTm9kZXMgPSAoZmlyc3QsIHJvd3MpID0+IHtcbiAgICAgICAgICAgIGxldCBub2RlcyA9IFtdO1xuXG4gICAgICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgcm93czsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IG5vZGUgPSB7XG4gICAgICAgICAgICAgICAgICAgIGtleTogKGZpcnN0ICsgaSksXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdJdGVtICcgKyAoZmlyc3QgKyBpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpemU6IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDEwMDApICsgMSArICdrYicsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnVHlwZSAnICsgKGZpcnN0ICsgaSlcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgbGVhZjogZmFsc2VcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgbm9kZXMucHVzaChub2RlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG5vZGVzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHsgbm9kZXMsIHJvd3MsIGxvYWRpbmcsIHRvdGFsUmVjb3Jkcywgb25FeHBhbmQsIG9uUGFnZSwgbG9hZE5vZGVzIH1cbiAgICB9XG4gICAgXG59XG48XFwvc2NyaXB0PlxuIgogICAgICAgIH0sCiAgICAgICAgJ2Jyb3dzZXItc291cmNlJzogewogICAgICAgICAgdGFiTmFtZTogJ0Jyb3dzZXIgU291cmNlJywKICAgICAgICAgIGltcG9ydHM6ICI8c2NyaXB0IHNyYz1cImh0dHBzOi8vdW5wa2cuY29tL3ByaW1ldnVlQF4zL3RyZWV0YWJsZS90cmVldGFibGUubWluLmpzXCI+PFxcL3NjcmlwdD5cbiAgICAgICAgPHNjcmlwdCBzcmM9XCJodHRwczovL3VucGtnLmNvbS9wcmltZXZ1ZUBeMy9jb2x1bW4vY29sdW1uLm1pbi5qc1wiPjxcXC9zY3JpcHQ+IiwKICAgICAgICAgIGNvbnRlbnQ6ICI8ZGl2IGlkPVwiYXBwXCI+XG4gICAgICAgICAgICA8cC10cmVldGFibGUgOnZhbHVlPVwibm9kZXNcIiA6bGF6eT1cInRydWVcIiA6cGFnaW5hdG9yPVwidHJ1ZVwiIDpyb3dzPVwicm93c1wiIDpsb2FkaW5nPVwibG9hZGluZ1wiXG4gICAgICAgICAgICAgICAgQG5vZGUtZXhwYW5kPVwib25FeHBhbmRcIiBAcGFnZT1cIm9uUGFnZVwiIDp0b3RhbC1yZWNvcmRzPVwidG90YWxSZWNvcmRzXCI+XG4gICAgICAgICAgICAgICAgPHAtY29sdW1uIGZpZWxkPVwibmFtZVwiIGhlYWRlcj1cIk5hbWVcIiA6ZXhwYW5kZXI9XCJ0cnVlXCI+PC9wLWNvbHVtbj5cbiAgICAgICAgICAgICAgICA8cC1jb2x1bW4gZmllbGQ9XCJzaXplXCIgaGVhZGVyPVwiU2l6ZVwiPjwvcC1jb2x1bW4+XG4gICAgICAgICAgICAgICAgPHAtY29sdW1uIGZpZWxkPVwidHlwZVwiIGhlYWRlcj1cIlR5cGVcIj48L3AtY29sdW1uPlxuICAgICAgICAgICAgPC9wLXRyZWV0YWJsZT5cbiAgICAgICAgPC9kaXY+ICAgICAgICAgICAgICAgICAgIFxuXG4gICAgICAgIDxzY3JpcHQgdHlwZT1cIm1vZHVsZVwiPlxuICAgICAgICBjb25zdCB7IGNyZWF0ZUFwcCwgcmVmLCBvbk1vdW50ZWQgfSA9IFZ1ZTtcblxuICAgICAgICBjb25zdCBBcHAgPSB7XG4gICAgICAgICAgICBzZXR1cCgpIHtcbiAgICAgICAgICAgICAgICBvbk1vdW50ZWQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBsb2FkaW5nLnZhbHVlID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvYWRpbmcudmFsdWUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVzLnZhbHVlID0gbG9hZE5vZGVzKDAsIHJvd3MudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdG90YWxSZWNvcmRzLnZhbHVlID0gMTAwMDtcbiAgICAgICAgICAgICAgICAgICAgfSwgMTAwMCk7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICBjb25zdCBub2RlcyA9IHJlZigpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJvd3MgPSByZWYoMTApO1xuICAgICAgICAgICAgICAgIGNvbnN0IGxvYWRpbmcgPSByZWYoZmFsc2UpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRvdGFsUmVjb3JkcyA9IHJlZigwKTtcbiAgICAgICAgICAgICAgICBjb25zdCBvbkV4cGFuZCA9IChub2RlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghbm9kZS5jaGlsZHJlbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9hZGluZy52YWx1ZSA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBsYXp5Tm9kZSA9IHsuLi5ub2RlfTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhenlOb2RlLmNoaWxkcmVuID0gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogbGF6eU5vZGUuZGF0YS5uYW1lICsgJyAtIDAnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpemU6IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDEwMDApICsgMSArICdrYicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ0ZpbGUnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogbGF6eU5vZGUuZGF0YS5uYW1lICsgJyAtIDEnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpemU6IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDEwMDApICsgMSArICdrYicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ0ZpbGUnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBdO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG5ld05vZGVzID0gbm9kZXMudmFsdWUubWFwKG4gPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobi5rZXkgPT09IG5vZGUua2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuID0gbGF6eU5vZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvYWRpbmcudmFsdWUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2Rlcy52YWx1ZSA9IG5ld05vZGVzO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSwgMjUwKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgY29uc3Qgb25QYWdlID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGxvYWRpbmcudmFsdWUgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vaW1pdGF0ZSBkZWxheSBvZiBhIGJhY2tlbmQgY2FsbFxuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvYWRpbmcudmFsdWUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVzLnZhbHVlID0gbG9hZE5vZGVzKGV2ZW50LmZpcnN0LCByb3dzLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgMTAwMCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBjb25zdCBsb2FkTm9kZXMgPSAoZmlyc3QsIHJvd3MpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG5vZGVzID0gW107XG5cbiAgICAgICAgICAgICAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IHJvd3M7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG5vZGUgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5OiAoZmlyc3QgKyBpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdJdGVtICcgKyAoZmlyc3QgKyBpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZTogTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTAwMCkgKyAxICsgJ2tiJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ1R5cGUgJyArIChmaXJzdCArIGkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZWFmOiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZXMucHVzaChub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBub2RlcztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4geyBub2Rlcywgcm93cywgbG9hZGluZywgdG90YWxSZWNvcmRzLCBvbkV4cGFuZCwgb25QYWdlLCBsb2FkTm9kZXMgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvbXBvbmVudHM6IHtcbiAgICAgICAgICAgICAgICBcInAtdHJlZXRhYmxlXCI6IHByaW1ldnVlLnRyZWV0YWJsZSxcbiAgICAgICAgICAgICAgICBcInAtY29sdW1uXCI6IHByaW1ldnVlLmNvbHVtblxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBcbiAgICAgICAgY3JlYXRlQXBwKEFwcClcbiAgICAgICAgICAgIC51c2UocHJpbWV2dWUuY29uZmlnLmRlZmF1bHQpXG4gICAgICAgICAgICAubW91bnQoXCIjYXBwXCIpO1xuICAgICAgICA8XFwvc2NyaXB0PlxuIgogICAgICAgIH0KICAgICAgfQogICAgfTsKICB9LAogIG1vdW50ZWQ6IGZ1bmN0aW9uIG1vdW50ZWQoKSB7CiAgICB2YXIgX3RoaXMgPSB0aGlzOwoKICAgIHRoaXMubG9hZGluZyA9IHRydWU7CiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsKICAgICAgX3RoaXMubG9hZGluZyA9IGZhbHNlOwogICAgICBfdGhpcy5ub2RlcyA9IF90aGlzLmxvYWROb2RlcygwLCBfdGhpcy5yb3dzKTsKICAgICAgX3RoaXMudG90YWxSZWNvcmRzID0gMTAwMDsKICAgIH0sIDEwMDApOwogIH0sCiAgbWV0aG9kczogewogICAgb25FeHBhbmQ6IGZ1bmN0aW9uIG9uRXhwYW5kKG5vZGUpIHsKICAgICAgdmFyIF90aGlzMiA9IHRoaXM7CgogICAgICBpZiAoIW5vZGUuY2hpbGRyZW4pIHsKICAgICAgICB0aGlzLmxvYWRpbmcgPSB0cnVlOwogICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgewogICAgICAgICAgdmFyIGxhenlOb2RlID0gX29iamVjdFNwcmVhZCh7fSwgbm9kZSk7CgogICAgICAgICAgbGF6eU5vZGUuY2hpbGRyZW4gPSBbewogICAgICAgICAgICBkYXRhOiB7CiAgICAgICAgICAgICAgbmFtZTogbGF6eU5vZGUuZGF0YS5uYW1lICsgJyAtIDAnLAogICAgICAgICAgICAgIHNpemU6IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDEwMDApICsgMSArICdrYicsCiAgICAgICAgICAgICAgdHlwZTogJ0ZpbGUnCiAgICAgICAgICAgIH0KICAgICAgICAgIH0sIHsKICAgICAgICAgICAgZGF0YTogewogICAgICAgICAgICAgIG5hbWU6IGxhenlOb2RlLmRhdGEubmFtZSArICcgLSAxJywKICAgICAgICAgICAgICBzaXplOiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxMDAwKSArIDEgKyAna2InLAogICAgICAgICAgICAgIHR5cGU6ICdGaWxlJwogICAgICAgICAgICB9CiAgICAgICAgICB9XTsKCiAgICAgICAgICB2YXIgbm9kZXMgPSBfdGhpczIubm9kZXMubWFwKGZ1bmN0aW9uIChuKSB7CiAgICAgICAgICAgIGlmIChuLmtleSA9PT0gbm9kZS5rZXkpIHsKICAgICAgICAgICAgICBuID0gbGF6eU5vZGU7CiAgICAgICAgICAgIH0KCiAgICAgICAgICAgIHJldHVybiBuOwogICAgICAgICAgfSk7CgogICAgICAgICAgX3RoaXMyLmxvYWRpbmcgPSBmYWxzZTsKICAgICAgICAgIF90aGlzMi5ub2RlcyA9IG5vZGVzOwogICAgICAgIH0sIDI1MCk7CiAgICAgIH0KICAgIH0sCiAgICBvblBhZ2U6IGZ1bmN0aW9uIG9uUGFnZShldmVudCkgewogICAgICB2YXIgX3RoaXMzID0gdGhpczsKCiAgICAgIHRoaXMubG9hZGluZyA9IHRydWU7IC8vaW1pdGF0ZSBkZWxheSBvZiBhIGJhY2tlbmQgY2FsbAoKICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7CiAgICAgICAgX3RoaXMzLmxvYWRpbmcgPSBmYWxzZTsKICAgICAgICBfdGhpczMubm9kZXMgPSBfdGhpczMubG9hZE5vZGVzKGV2ZW50LmZpcnN0LCBfdGhpczMucm93cyk7CiAgICAgIH0sIDEwMDApOwogICAgfSwKICAgIGxvYWROb2RlczogZnVuY3Rpb24gbG9hZE5vZGVzKGZpcnN0LCByb3dzKSB7CiAgICAgIHZhciBub2RlcyA9IFtdOwoKICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByb3dzOyBpKyspIHsKICAgICAgICB2YXIgbm9kZSA9IHsKICAgICAgICAgIGtleTogZmlyc3QgKyBpLAogICAgICAgICAgZGF0YTogewogICAgICAgICAgICBuYW1lOiAnSXRlbSAnICsgKGZpcnN0ICsgaSksCiAgICAgICAgICAgIHNpemU6IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDEwMDApICsgMSArICdrYicsCiAgICAgICAgICAgIHR5cGU6ICdUeXBlICcgKyAoZmlyc3QgKyBpKQogICAgICAgICAgfSwKICAgICAgICAgIGxlYWY6IGZhbHNlCiAgICAgICAgfTsKICAgICAgICBub2Rlcy5wdXNoKG5vZGUpOwogICAgICB9CgogICAgICByZXR1cm4gbm9kZXM7CiAgICB9CiAgfQp9Ow=="},{"version":3,"sources":["/Users/crocslut/Desktop/Git/main-cleanaway-pwa/src/views/treetable/TreeTableLazyDemo.vue"],"names":[],"mappings":"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","sourcesContent":["<template>\n    <div>\n        <div class=\"content-section introduction\">\n            <div class=\"feature-intro\">\n                <h1>TreeTable <span>Lazy</span></h1>\n                <p>Lazy mode is handy to deal with large datasets, instead of loading the entire data, small chunks of data is loaded by invoking corresponding callbacks everytime paging or sorting. In addition,\n                    children of a node can be loaded on demand at onNodeExpand event as well. Sample belows imitates lazy paging by using an in memory list..</p>\n            </div>\n            <AppDemoActions />\n        </div>\n\n        <div class=\"content-section implementation\">\n            <div class=\"card\">\n                <TreeTable :value=\"nodes\" :lazy=\"true\" :paginator=\"true\" :rows=\"rows\" :loading=\"loading\"\n                    @node-expand=\"onExpand\" @page=\"onPage\" :totalRecords=\"totalRecords\">\n                    <Column field=\"name\" header=\"Name\" :expander=\"true\"></Column>\n                    <Column field=\"size\" header=\"Size\"></Column>\n                    <Column field=\"type\" header=\"Type\"></Column>\n                </TreeTable>\n            </div>\n        </div>\n\n        <AppDoc name=\"TreeTableLazyDemo\" :sources=\"sources\" :service=\"['NodeService']\" :data=\"['treetablenodes']\" github=\"treetable/TreeTableLazyDemo.vue\" />\n    </div>\n</template>\n\n<script>\nexport default {\n    data() {\n        return {\n            nodes: null,\n            rows: 10,\n            loading: false,\n            totalRecords: 0,\n            sources: {\n                'options-api': {\n                    tabName: 'Options API Source',\n                    content: `\n<template>\n    <div>\n        <TreeTable :value=\"nodes\" :lazy=\"true\" :paginator=\"true\" :rows=\"rows\" :loading=\"loading\"\n            @nodeExpand=\"onExpand\" @page=\"onPage\" :totalRecords=\"totalRecords\">\n            <Column field=\"name\" header=\"Name\" :expander=\"true\"></Column>\n            <Column field=\"size\" header=\"Size\"></Column>\n            <Column field=\"type\" header=\"Type\"></Column>\n        </TreeTable>\n    </div>                   \n</template>\n\n<script>\nexport default {\n    data() {\n        return {\n            nodes: null,\n            rows: 10,\n            loading: false,\n            totalRecords: 0\n        }\n    },\n    mounted() {\n        this.loading = true;\n\n        setTimeout(() => {\n            this.loading = false;\n            this.nodes = this.loadNodes(0, this.rows);\n            this.totalRecords = 1000;\n        }, 1000);\n    },\n    methods: {\n        onExpand(node) {\n            if (!node.children) {\n                this.loading = true;\n\n                setTimeout(() => {\n                    let lazyNode = {...node};\n\n                    lazyNode.children = [\n                        {\n                            data: {\n                                name: lazyNode.data.name + ' - 0',\n                                size: Math.floor(Math.random() * 1000) + 1 + 'kb',\n                                type: 'File'\n                            },\n                        },\n                        {\n                            data: {\n                                name: lazyNode.data.name + ' - 1',\n                                size: Math.floor(Math.random() * 1000) + 1 + 'kb',\n                                type: 'File'\n                            }\n                        }\n                    ];\n\n                    let nodes = this.nodes.map(n => {\n                        if (n.key === node.key) {\n                            n = lazyNode;\n                        }\n\n                        return n;\n                    });\n\n                    this.loading = false;\n                    this.nodes = nodes;\n                }, 250);\n            }\n        },\n        onPage(event) {\n            this.loading = true;\n\n            //imitate delay of a backend call\n            setTimeout(() => {\n                this.loading = false;\n                this.nodes = this.loadNodes(event.first, this.rows);\n            }, 1000);\n        },\n        loadNodes(first, rows) {\n            let nodes = [];\n\n            for(let i = 0; i < rows; i++) {\n                let node = {\n                    key: (first + i),\n                    data: {\n                        name: 'Item ' + (first + i),\n                        size: Math.floor(Math.random() * 1000) + 1 + 'kb',\n                        type: 'Type ' + (first + i)\n                    },\n                    leaf: false\n                };\n\n                nodes.push(node);\n            }\n\n            return nodes;\n        }\n    }\n}\n<\\\\/script>\n`\n                },\n                'composition-api': {\n                    tabName: 'Composition API Source',\n                    content: `\n<template>\n    <div>\n        <TreeTable :value=\"nodes\" :lazy=\"true\" :paginator=\"true\" :rows=\"rows\" :loading=\"loading\"\n            @nodeExpand=\"onExpand\" @page=\"onPage\" :totalRecords=\"totalRecords\">\n            <Column field=\"name\" header=\"Name\" :expander=\"true\"></Column>\n            <Column field=\"size\" header=\"Size\"></Column>\n            <Column field=\"type\" header=\"Type\"></Column>\n        </TreeTable>\n    </div>                   \n</template>\n\n<script>\nimport { ref, onMounted } from 'vue';\n\nexport default {\n    setup() {\n        onMounted(() => {\n            loading.value = true;\n\n            setTimeout(() => {\n                loading.value = false;\n                nodes.value = loadNodes(0, rows.value);\n                totalRecords.value = 1000;\n            }, 1000);\n        })\n        const nodes = ref();\n        const rows = ref(10);\n        const loading = ref(false);\n        const totalRecords = ref(0);\n        const onExpand = (node) => {\n            if (!node.children) {\n                loading.value = true;\n\n                setTimeout(() => {\n                    let lazyNode = {...node};\n\n                    lazyNode.children = [\n                        {\n                            data: {\n                                name: lazyNode.data.name + ' - 0',\n                                size: Math.floor(Math.random() * 1000) + 1 + 'kb',\n                                type: 'File'\n                            },\n                        },\n                        {\n                            data: {\n                                name: lazyNode.data.name + ' - 1',\n                                size: Math.floor(Math.random() * 1000) + 1 + 'kb',\n                                type: 'File'\n                            }\n                        }\n                    ];\n\n                    let newNodes = nodes.value.map(n => {\n                        if (n.key === node.key) {\n                            n = lazyNode;\n                        }\n\n                        return n;\n                    });\n\n                    loading.value = false;\n                    nodes.value = newNodes;\n                }, 250);\n            }\n        };\n        const onPage = (event) => {\n            loading.value = true;\n\n            //imitate delay of a backend call\n            setTimeout(() => {\n                loading.value = false;\n                nodes.value = loadNodes(event.first, rows.value);\n            }, 1000);\n        };\n        const loadNodes = (first, rows) => {\n            let nodes = [];\n\n            for(let i = 0; i < rows; i++) {\n                let node = {\n                    key: (first + i),\n                    data: {\n                        name: 'Item ' + (first + i),\n                        size: Math.floor(Math.random() * 1000) + 1 + 'kb',\n                        type: 'Type ' + (first + i)\n                    },\n                    leaf: false\n                };\n\n                nodes.push(node);\n            }\n\n            return nodes;\n        }\n\n        return { nodes, rows, loading, totalRecords, onExpand, onPage, loadNodes }\n    }\n    \n}\n<\\\\/script>\n`\n                },\n                'browser-source': {\n                    tabName: 'Browser Source',\n                    imports: `<script src=\"https://unpkg.com/primevue@^3/treetable/treetable.min.js\"><\\\\/script>\n        <script src=\"https://unpkg.com/primevue@^3/column/column.min.js\"><\\\\/script>`,\n                    content: `<div id=\"app\">\n            <p-treetable :value=\"nodes\" :lazy=\"true\" :paginator=\"true\" :rows=\"rows\" :loading=\"loading\"\n                @node-expand=\"onExpand\" @page=\"onPage\" :total-records=\"totalRecords\">\n                <p-column field=\"name\" header=\"Name\" :expander=\"true\"></p-column>\n                <p-column field=\"size\" header=\"Size\"></p-column>\n                <p-column field=\"type\" header=\"Type\"></p-column>\n            </p-treetable>\n        </div>                   \n\n        <script type=\"module\">\n        const { createApp, ref, onMounted } = Vue;\n\n        const App = {\n            setup() {\n                onMounted(() => {\n                    loading.value = true;\n\n                    setTimeout(() => {\n                        loading.value = false;\n                        nodes.value = loadNodes(0, rows.value);\n                        totalRecords.value = 1000;\n                    }, 1000);\n                })\n                const nodes = ref();\n                const rows = ref(10);\n                const loading = ref(false);\n                const totalRecords = ref(0);\n                const onExpand = (node) => {\n                    if (!node.children) {\n                        loading.value = true;\n\n                        setTimeout(() => {\n                            let lazyNode = {...node};\n\n                            lazyNode.children = [\n                                {\n                                    data: {\n                                        name: lazyNode.data.name + ' - 0',\n                                        size: Math.floor(Math.random() * 1000) + 1 + 'kb',\n                                        type: 'File'\n                                    },\n                                },\n                                {\n                                    data: {\n                                        name: lazyNode.data.name + ' - 1',\n                                        size: Math.floor(Math.random() * 1000) + 1 + 'kb',\n                                        type: 'File'\n                                    }\n                                }\n                            ];\n\n                            let newNodes = nodes.value.map(n => {\n                                if (n.key === node.key) {\n                                    n = lazyNode;\n                                }\n\n                                return n;\n                            });\n\n                            loading.value = false;\n                            nodes.value = newNodes;\n                        }, 250);\n                    }\n                };\n                const onPage = (event) => {\n                    loading.value = true;\n\n                    //imitate delay of a backend call\n                    setTimeout(() => {\n                        loading.value = false;\n                        nodes.value = loadNodes(event.first, rows.value);\n                    }, 1000);\n                };\n                const loadNodes = (first, rows) => {\n                    let nodes = [];\n\n                    for(let i = 0; i < rows; i++) {\n                        let node = {\n                            key: (first + i),\n                            data: {\n                                name: 'Item ' + (first + i),\n                                size: Math.floor(Math.random() * 1000) + 1 + 'kb',\n                                type: 'Type ' + (first + i)\n                            },\n                            leaf: false\n                        };\n\n                        nodes.push(node);\n                    }\n\n                    return nodes;\n                }\n\n                return { nodes, rows, loading, totalRecords, onExpand, onPage, loadNodes }\n            },\n            components: {\n                \"p-treetable\": primevue.treetable,\n                \"p-column\": primevue.column\n            }\n        };\n        \n        createApp(App)\n            .use(primevue.config.default)\n            .mount(\"#app\");\n        <\\\\/script>\n`\n                }\n            }\n        }\n    },\n    mounted() {\n        this.loading = true;\n\n        setTimeout(() => {\n            this.loading = false;\n            this.nodes = this.loadNodes(0, this.rows);\n            this.totalRecords = 1000;\n        }, 1000);\n    },\n    methods: {\n        onExpand(node) {\n            if (!node.children) {\n                this.loading = true;\n\n                setTimeout(() => {\n                    let lazyNode = {...node};\n\n                    lazyNode.children = [\n                        {\n                            data: {\n                                name: lazyNode.data.name + ' - 0',\n                                size: Math.floor(Math.random() * 1000) + 1 + 'kb',\n                                type: 'File'\n                            },\n                        },\n                        {\n                            data: {\n                                name: lazyNode.data.name + ' - 1',\n                                size: Math.floor(Math.random() * 1000) + 1 + 'kb',\n                                type: 'File'\n                            }\n                        }\n                    ];\n\n                    let nodes = this.nodes.map(n => {\n                        if (n.key === node.key) {\n                            n = lazyNode;\n                        }\n\n                        return n;\n                    });\n\n                    this.loading = false;\n                    this.nodes = nodes;\n                }, 250);\n            }\n        },\n        onPage(event) {\n            this.loading = true;\n\n            //imitate delay of a backend call\n            setTimeout(() => {\n                this.loading = false;\n                this.nodes = this.loadNodes(event.first, this.rows);\n            }, 1000);\n        },\n        loadNodes(first, rows) {\n            let nodes = [];\n\n            for(let i = 0; i < rows; i++) {\n                let node = {\n                    key: (first + i),\n                    data: {\n                        name: 'Item ' + (first + i),\n                        size: Math.floor(Math.random() * 1000) + 1 + 'kb',\n                        type: 'Type ' + (first + i)\n                    },\n                    leaf: false\n                };\n\n                nodes.push(node);\n            }\n\n            return nodes;\n        }\n    }\n}\n</script>"],"sourceRoot":""}]}